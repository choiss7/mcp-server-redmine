# ユニットテスト戦略

## ステータス

承認済み - 2025-01-06
更新 - 2025-01-06 - テストの安全性方針を明確化
完了 - 2025-01-06

## コンテキスト

Redmine 用 MCP サーバーのコード品質と信頼性を確保するためにユニットテストが必要です。以下の ADR を経て実装が安定してきました：

1. プロジェクトの基本構造（0001）
2. API 実装（0002、破棄）
3. モジュールの分割（0003）
4. クライアントと型定義の分割（0006）

特に、データの安全性に関して以下の点を考慮する必要があります：

1. テスト実行時の実データへの影響防止
2. API 呼び出しの安全性確保
3. テスト環境と本番環境の分離
4. 意図しないデータ変更の防止

## 決定

### 1. テストの安全性戦略

#### 1.1. テスト対象の制限

- **GET 操作のみをテスト対象とする**

  - データの読み取りのみを行う GET 操作をテスト
  - レスポンスの形式とデータ構造の検証に焦点
  - エラーケースも含めて包括的にテスト

- **データ変更操作のテストは除外**
  - POST（作成）操作は全てスキップ
  - PUT（更新）操作は全てスキップ
  - DELETE（削除）操作は全てスキップ
  - スキップの理由を各テストファイルに明確に記述

#### 1.2. テストファイルの構成

```typescript
describe("API Method (POST/PUT/DELETE)", () => {
  // データ変更操作のテストはスキップ
  it.skip("all operations are skipped for safety", () => {
    // API仕様とスキップ理由を詳細に記述
    // - 受け付けるパラメータ
    // - 操作の影響
    // - スキップの理由
  });
});

describe("API Method (GET)", () => {
  // 通常のケース
  it("fetches data successfully", async () => {
    // GETリクエストのテスト実装
  });

  // エラーケース
  it("handles API error appropriately", async () => {
    // エラーハンドリングのテスト実装
  });
});
```

#### 1.3. モックの使用方針

- **fetch のモック化**

  - グローバルな fetch をモックして実 API 呼び出しを防止
  - 未定義の fetch 呼び出しはエラーを投げるように設定
  - レスポンスは全てモックデータを使用

- **レスポンスデータの管理**
  - テストフィクスチャとして定義
  - API の実際のレスポンス形式に準拠
  - 必要最小限のデータセットを用意

### 2. テスト実装のプロセス

各 API エンドポイントのテストを実装する際は、以下の手順で進める：

1. **メソッドの分類**

   - GET 操作の場合: テストを実装
   - POST/PUT/DELETE 操作の場合: スキップ理由を文書化

2. **GET 操作のテスト実装**

   - API 仕様の確認
   - レスポンス形式の検証
   - エラーケースの検証
   - パラメータの検証

3. **テストの文書化**
   - スキップする操作の理由を明記
   - API 仕様との整合性を説明
   - 実装上の制約や拡張を記述

### 3. カバレッジの考え方

- **測定対象の調整**

  - GET 操作に関する部分のみをカバレッジ計測の対象とする
  - データ変更操作のスキップによるカバレッジ低下は許容

- **品質指標**
  - GET メソッドに関しては高いカバレッジを維持
  - エラーケースの網羅的なテスト
  - レスポンス形式の完全な検証

### 4. 実装構造

テストファイルは以下の構造で整理する：

```
src/
├── lib/
│   ├── __tests__/
│   │   ├── helpers/          # テストヘルパー
│   │   │   ├── fixtures.ts   # テストデータ
│   │   │   ├── setup.ts      # グローバル設定
│   │   │   └── mocks.ts      # 共通モック
│   │   ├── client/           # クライアントのテスト
│   │   │   ├── base/         # 基本機能のテスト
│   │   │   │   ├── request.test.ts
│   │   │   │   └── params.test.ts
│   │   │   ├── issues/       # Issues APIのテスト
│   │   │   │   ├── get.test.ts
│   │   │   │   ├── post.test.ts
│   │   │   │   ├── put.test.ts
│   │   │   │   └── delete.test.ts
│   │   │   ├── projects/     # Projects APIのテスト
│   │   │   └── time_entries/ # TimeEntries APIのテスト
│   │   └── types/            # 型のテスト
│   │       ├── issues/
│   │       ├── projects/
│   │       └── time_entries/
```

この構造の利点：

- 機能ごとのテストファイルの分離（API、クライアント基本機能、型）
- ドメインごとのテストの整理（issues, projects, time_entries）
- テストコードの見通しの向上
- メンテナンスの容易化
- テストヘルパーの再利用性の向上

主要なテストファイルの役割：

1. **base/**

   - リクエスト処理の共通機能
   - パラメータ処理のユーティリティ
   - エラーハンドリング

2. **helpers/**

   - `fixtures.ts`: テストデータの定義
   - `setup.ts`: Jest 設定とグローバルモック
   - `mocks.ts`: モックレスポンス生成

3. **各 API のテストディレクトリ**
   - `get.test.ts`: GET リクエストの完全なテスト
   - `post.test.ts`, `put.test.ts`, `delete.test.ts`: 操作説明とスキップ理由

## 結果

### 肯定的な結果

1. **安全性の向上**

   - データ変更操作の完全な除外による安全性確保
   - 意図しない API 呼び出しの防止
   - テスト環境の保護

2. **テストの明確化**

   - テスト対象の明確な定義
   - スキップ理由の文書化
   - API 仕様との整合性の確保

3. **保守性の向上**
   - テストファイルの構造の統一
   - テスト範囲の明確な境界
   - 文書化された制約事項

### 否定的な結果

1. **カバレッジへの影響**

   - データ変更操作のテストスキップによるカバレッジ低下
   - 実際の成功ケースの動作確認が限定的

2. **テストの制限**

   - データ作成・更新・削除の動作確認が手動に依存
   - 環境依存の問題の早期発見が困難

3. **運用上の課題**
   - 手動テストの重要性が増加
   - 本番環境での慎重な検証が必要

## 参考資料

- [Jest Documentation](https://jestjs.io/docs/getting-started)
- [Redmine REST API](https://www.redmine.org/projects/redmine/wiki/Rest_api)
- [Issues REST API](https://www.redmine.org/projects/redmine/wiki/Rest_Issues)
- [ADR 0007: ユニットテストのツールと設定](./0007-unit-testing-tools-and-configs.md)


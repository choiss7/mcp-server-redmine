# ユニットテスト戦略

## ステータス

承認済み - 2025-01-06
実装開始 - 2025-01-06
更新 - 2025-01-06
第7版 - 2025-01-06

## コンテキスト

Redmine用MCPサーバーのコード品質と信頼性を確保するためにユニットテストが必要です。以下のADRを経て実装が安定してきました：

1. プロジェクトの基本構造（0001）
2. API実装（0002、破棄）
3. モジュールの分割（0003）
4. クライアントと型定義の分割（0006）

以下の点を考慮したテスト戦略を決定し実装を進める必要があります：

1. モジュール分割によりテストが容易になった点
2. モジュールごとに異なるタイプのテストが必要な点
3. 外部依存（Redmine API）のモック戦略
4. Redmine APIの仕様に準拠した実装の検証
5. テストコードの保守性と可読性の確保
6. クライアントの分割に伴うテストの再構築（ADR 0006による変更）

## 決定

### テストの安全性戦略

1. **データ変更操作の取り扱い**
   - POST（作成）、PUT（更新）、DELETE（削除）の成功ケースはスキップ
   - これらの操作のエラーケースのみをテスト
   - テストコードに意図を明確に記述（スキップ理由のコメント等）

2. **エラーケースの優先的なテスト**
   - 権限エラー（403）
   - リソース不在エラー（404）
   - バリデーションエラー（422）
   - サーバーエラー（500）
   など、データに影響を与えないエラーケースを重点的にテスト

3. **モックの使用**
   - 実際のAPIコールは行わない
   - モックレスポンスのみを使用
   - エラーレスポンスの形式は実際のAPIに準拠

テスト例：
```typescript
describe("Issues API (POST)", () => {
  // 成功ケースはスキップ
  it.skip("creates a new issue", async () => {
    // このテストは実データを変更する可能性があるためスキップ
  });

  // エラーケースはテスト
  it("handles validation error", async () => {
    mockFetch.mockResolvedValueOnce(
      mockResponse(
        { errors: ['Subject cannot be blank'] },
        { status: 422, statusText: 'Unprocessable Entity' }
      )
    );

    await expect(client.createIssue(invalidData))
      .rejects
      .toThrow(RedmineApiError);
  });
});
```

### テスト実装のプロセス

各APIエンドポイントのテストを実装する際は、以下の手順で進める：

1. **安全性の確認**
   - テストが実データに影響を与えないことを確認
   - データを変更する操作（POST/PUT/DELETE）は原則としてスキップ
   - エラーケースのテストを優先的に実装

2. **API仕様の確認**
   - RedmineのREST API仕様を確認
   - エンドポイントの詳細な仕様を確認（パラメータ、レスポンス形式等）
   - バージョンによる違いの有無を確認

3. **既存コードの確認**
   - 実装済みのコードを確認
   - API仕様との整合性を確認
   - 実装上の制約や拡張を確認

4. **テストケースの実装**
   - エラーケース（優先的に実装）
   - エッジケース
   - 基本的なケース（データ変更を伴わないもの）
   - Redmine API仕様に基づく検証

### ファイル構造

テストの保守性と可読性を向上させるため、以下のような構造でテストファイルを分割：

```
src/
├── lib/
│   ├── __tests__/
│   │   ├── helpers/          # テストヘルパー
│   │   │   ├── fixtures.ts   # テストデータ
│   │   │   ├── setup.ts      # グローバル設定
│   │   │   └── mocks.ts      # 共通モック
│   │   ├── client/           # クライアントのテスト
│   │   │   ├── base/         # 基本機能のテスト
│   │   │   │   ├── request.test.ts
│   │   │   │   └── params.test.ts
│   │   │   ├── issues/       # Issues APIのテスト
│   │   │   │   ├── get.test.ts
│   │   │   │   ├── post.test.ts
│   │   │   │   ├── put.test.ts
│   │   │   │   └── delete.test.ts
│   │   │   ├── projects/     # Projects APIのテスト
│   │   │   └── time_entries/ # TimeEntries APIのテスト
│   │   └── types/            # 型のテスト
│   │       ├── issues/
│   │       ├── projects/
│   │       └── time_entries/
```

この構造の利点：
- 機能ごとのテストファイルの分離
- ドメインごとのテストの整理
- テストコードの見通しの向上
- メンテナンスの容易化
- チーム開発時の競合リスクの低減
- クライアント分割に対応した構造

### 実装状況（2025-01-06第4版）

1. **テスト環境の整備**（完了）
   - ベースとなるテスト環境の構築
   - TypeScriptサポートの設定
   - グローバルモックの実装
   - jest.config.tsの設定
   - ts-jestの設定

2. **型定義の改善**（進行中）
   - ベーステストの実装完了
   - `base.test.ts`での型定義の適用成功
   - `issues/get.test.ts`の型定義の修正完了
     - `jest.SpyInstance`から`Mock`型への移行
     - グローバルモックの正しい型付け
   - 残りのテストファイルは未修正
     - `post.test.ts`
     - `put.test.ts`
     - `delete.test.ts`

## 結果

### 肯定的な結果

1. テストの整理と管理
   - API仕様に基づく体系的なテスト実装が可能に
   - モジュール構造に合わせたテストの整理
   - テストヘルパーとフィクスチャの再利用
   - HTTPリクエストのモック化による安定したテスト

2. 実装プロセス
   - プロセスの標準化によるテスト品質の均一化
   - テストファイルの分割による保守性の向上
   - テストケースの見通しの改善
   - グローバルモックの一元管理

3. モジュール分割効果
   - 個別のクライアントテストが容易に
   - 依存関係が明確で影響範囲が把握しやすい
   - 共通機能のテストが再利用可能

4. テストの安全性
   - データ変更操作のスキップによる実環境への影響防止
   - エラーケースの優先的なテストによる安全性の向上
   - モックの活用による実APIへのアクセス制限

### 否定的な結果

1. コスト面
   - ファイル数の増加に伴う初期学習コストの上昇
   - API仕様の詳細な確認が必要で実装に時間がかかる
   - モジュール分割による再実装の必要性

2. 管理面
   - フィクスチャの保守が必要
   - テストファイル間の依存関係の管理が必要
   - モックの一貫性維持が必要

3. テストカバレッジ
   - データ変更操作のテストスキップによるカバレッジの低下
   - 実際の成功ケースの動作確認が限定的

## 参考資料

- [Redmine REST API](https://www.redmine.org/projects/redmine/wiki/Rest_api)
- [Issues REST API](https://www.redmine.org/projects/redmine/wiki/Rest_Issues)
- [ADR 0007: ユニットテストのツールと設定](./0007-unit-testing-tools-and-configs.md)